README

内存分配方法的描述、选择与讨论
在本次大作业中，一共可以使用的内存分配方法共有4种，他们分别是：首次匹配、下次匹配、
最优匹配、最差匹配。
首次匹配指：找到第一个能够满足内存需求的内存块，将其分配。
下次匹配指：在首次匹配的基础上，将其每一次开始查找的位置改变为上一次分配的内存空间，
从而使得查找能够分布于全空间。
最优匹配指：找到内存块中能够满足内存需求且最小的内存块，将其分配。
最差匹配指：找到内存块中能够满足内存需求且最大的内存块，将其分配。
据教材描述，下次匹配是对首次匹配的优化，那么首次匹配首先被淘汰。同时最优匹配的表现在大多数情况
下都优于最差匹配。其实，从逻辑推导也可以知道，如果每一次都切割较大的内存块，那么剩余的内存块普遍都较小
，也就不能够容纳可能到来的一个较大的内存需求。因此范围被限定在下次匹配和最优匹配之中。同时，由于本项目
使用的进程数较少，其复杂性并不大，遍历内存块链表消耗的时间不长，最优匹配的缺点能够得到部分补偿。而下次匹配
的快速优势被相对抑制。故我选择的内存分配算法是最优匹配。

HOST调度器的结构
调度器第一层结构是输入队列，该队列存储着从文件中读取的各进程。
第二层结构是实时进程队列和用户进程队列。从输入队列中读取的合法进程按优先级分别进入这两个队列。
第三层结构是feedback队列，该队列又由3个优先级队列组成。对于其中的第1、2级队列，如果其中进程
执行完一个时间片后没能完成，其会退出该队列，进入下一级队列。对于第3级队列，其使用轮转算法，直至
进程完成。

程序框架和各个模块
HOST程序在运行时是靠两个独立的程序共同支持而得到的。其中一个程序由sigtrap.c编译而来，另一个
程序由hostd.c和其配套的pcb.c mab.c rsrc.c编译而来。sigtrap.c这个程序主要用于捕获某些信号，同时
进行计时、指定颜色等操作，而hostd.c程序及其配套文件则是HOST的主体。
pcb.c/pcb.h:这个头文件及其C文件主要定义了进程这个结构体，同时定义并实现了对于进程(队列）的各个操作。
包括了进程创建、开始、暂停、终止、入队、出队、打印等。
mab.c/mab.h：对于这个头文件，其主要定义了内存这个结构体及队列（指针），同时实现了针对内存的各个操作
如：内存检查、内存分割、内存释放、内存合并等。
rsrc.c/rsrc.h：对于这个文件，其主要定义了资源这个结构体和对其的操作。例如资源检查（是否充足）、资源分配、
资源释放等操作。
而在hostd.c这个文件中，我们主要利用了上述各个模块所提供的操作，用一个大循环和时间计数实现了类似与进程实际
时间中的分配的一个过程。在hostd.c这个文件中，我们会按照各个条件执行某些操作，包括从实际文件中读取进程进入
输入队列，从输入队列讲进程分队，选择进程同时执行、打印信息。



进程调度、内存分配、资源分配等策略的总结与讨论
进程调度：对于本HOST程序的进程调度策略，我认为大致上较为符合真实的调度情况。但是，我认为在某些小细节上
能够有所改进。
比如，我认为在用户进程入队时，可以有所改进。现在我们采取的方式是如果用户进程队列的头部进程
内存、资源要求不能被满足，就一直等待。实际上，当这种情况发生时可以遍历队列，查询队列中的每一个进程，看其
内存等需求是否满足，一旦满足，就可以让其入队同时分配资源。这个改进，可以使得CPU的使用效率进一步提升。
此外，在本次HOST程序中，我们考虑了IO资源，但是没有考虑进程可能会存在的IO交互时间，如果将此编入程序，将使得该
程序进一步符合现实。
最后，由于我们采用的文件中进程数较少，而生活中的实际情况是进程数很多，只要电脑在使用，几乎就在运行进程。我们的
简化使得我们忽视了一个严重的问题：饥饿。如果有很多个实时进程（最高优先级进程）不断的进入我们的调度器，那么所有
用户程序都不能运行，这将会导致饥饿。而解决办法就是每隔一段时间提升剩余进程的优先级，同时取消实时进程的特权，使其
变成一个优先级最高的用户进程，而不是一个凌驾在用户进程之上的特殊进程。

内存分配：由于我们现在采用的内存分配是连续式的，实际上和现代的操作系统经常采用的分页式方法不同，我认为可以
采用分页式内存分配，这样会增加我们这个程序的实际性同时提升其面对复杂内存分配时的性能。当然，这样需要很多修正，
同时会较大地增加程序复杂度。

资源分配：我认为本次程序使用的资源分配是简单而且实用的。在我们现实生活中，我们实际上只需把程序中使用到的静态
资源结构体完全复制同时根据I/O设备的使用情况进行修正即可，不需要太大的改动。